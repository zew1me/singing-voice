"""Command line interface for the singing-voice pipeline."""
from __future__ import annotations

from pathlib import Path
from typing import Optional

import typer

from .preprocess import PreprocessorConfig, preprocess_audio_file
from .seedvc_client import submit_to_runpod
from .stitch import StitchConfig, stitch_manifest_to_file
from .workdir import DEFAULT_WORKDIR, SessionPaths

app = typer.Typer(help="Librosa preprocessing + Seed-VC stitching utilities.")


@app.command()
def preprocess(
    audio_path: Path = typer.Argument(..., help="Input WAV/AIFF/MP3 file."),
    manifest_path: Optional[Path] = typer.Option(
        None,
        "--manifest-path",
        help="Where to store the manifest JSON. Defaults to working/<stem>/manifest.json",
    ),
    workdir: Path = typer.Option(DEFAULT_WORKDIR, help="Root directory for generated files."),
    chunk_seconds: float = typer.Option(12.0, help="Nominal chunk duration in seconds."),
    overlap_seconds: float = typer.Option(1.5, help="Overlap duration between chunks."),
    silence_threshold_db: float = typer.Option(-40.0, help="dB threshold for detecting audio."),
    min_chunk_seconds: float = typer.Option(0.15, help="Minimum trimmed chunk length."),
    sample_rate: int = typer.Option(16_000, help="Sample rate for librosa.load and output files."),
):
    """Chunk + serialize audio so the RunPod worker can run inference."""

    audio_path = audio_path.expanduser().resolve()
    config = PreprocessorConfig(
        sample_rate=sample_rate,
        chunk_seconds=chunk_seconds,
        overlap_seconds=overlap_seconds,
        silence_threshold_db=silence_threshold_db,
        min_chunk_seconds=min_chunk_seconds,
    )

    manifest_target = manifest_path
    if manifest_target is None:
        session = SessionPaths.create(audio_path.stem, workdir=workdir)
        manifest_target = session.manifest
    else:
        manifest_target = manifest_target.expanduser().resolve()
        manifest_target.parent.mkdir(parents=True, exist_ok=True)

    manifest = preprocess_audio_file(audio_path, manifest_target, config=config)
    typer.echo(
        f"Wrote manifest with {len(manifest.chunks)} chunks to {manifest_target}"
    )


@app.command()
def stitch(
    converted_manifest: Path = typer.Argument(..., help="JSON output from the Seed-VC worker."),
    output_path: Path = typer.Option(
        DEFAULT_WORKDIR / "stitched.wav",
        "--output",
        help="Where to place the stitched WAV file.",
    ),
    crossfade_seconds: float = typer.Option(1.5, help="Crossfade duration for overlaps."),
    sample_rate: int = typer.Option(16_000, help="Sample rate for the output WAV."),
):
    """Stitch converted chunks into a single WAV file."""

    cfg = StitchConfig(sample_rate=sample_rate, crossfade_seconds=crossfade_seconds)
    path = stitch_manifest_to_file(converted_manifest, output_path, config=cfg)
    typer.echo(f"Created {path}")


@app.command("submit-runpod")
def submit_runpod(
    manifest_path: Path = typer.Argument(..., help="Manifest generated by the preprocess command."),
    endpoint: str = typer.Option(..., help="RunPod serverless endpoint that runs Seed-VC."),
    api_key: Optional[str] = typer.Option(None, envvar="RUNPOD_API_KEY", help="Bearer token."),
    timeout: int = typer.Option(600, help="HTTP timeout in seconds."),
    output_path: Optional[Path] = typer.Option(
        DEFAULT_WORKDIR / "converted_manifest.json",
        "--output",
        help="Where to write the converted manifest returned by the worker.",
    ),
):
    """Send chunks to the Seed-VC worker and store the returned manifest."""

    manifest_path = manifest_path.expanduser().resolve()
    if output_path is not None:
        output_path = output_path.expanduser().resolve()

    converted = submit_to_runpod(
        manifest_path=manifest_path,
        endpoint=endpoint,
        api_key=api_key,
        timeout=timeout,
        output_path=output_path,
    )

    typer.echo(
        f"Seed-VC returned {len(converted.converted_chunks)} chunks. Saved manifest to {output_path}"
    )


if __name__ == "__main__":
    app()
